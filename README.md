# Выжимка по работе с MongoDB 

Поскольку книга по MongoDB занимает порядка 500 страниц, а гуглить избитые вопросы глупо, мною было принято решение сделать небольшую шпаргалку по MongoDB, пока все эти нюансы не залезут в голову за годы оттачивания рук. Нюансы будут дополнятся в ходе столкновения проблемами или особенностями данной NoSQL базы данных.

## Оглавление
- [Когда не стоит использовать MongoDB](#когда-не-стоит-использовать-mongoDB)
- [Типы данных в MongoDB и операторы сравнения](#типы-данных-в-mongoDB-и-операторы-сравнения)
- [Запросы с Find](#запросы-с-find)
- [Операторы запроса](#операторы-запроса)
- [Запросы для определённых типов данных](#запросы-для-определённых-типов-данных)
- [Лимитирование, пропуск данных, сравнение и сортировка](#лимитирование-пропуск-данных-сравнение-и-сортировка)
- [Аккумуляторы](#аккумуляторы)
- [Агрегации](#агрегации)
- [Индексы](#индексы)
- [Нормализация и денормализация](#нормализация-и-денормализация)
- [Populate](#populate)

## Когда не стоит использовать MongoDB

Тогда, когда нам нужно использовать реляционные базы данных...и тем самым создать Холивар...На самом деле не стоит использовать если: <br/>
- Данные, которые необходимо вбивать являются систематическими с одним уровнем вложенности, проще говоря если база данных состоит из описания сущности электротехники, которая имеет конкретные данные по типу: вес, размер, номер модели, серии, год выпуска и т.д., тогда это проще как и хранить, так и обрабатывать в форме таблички. <br/>
MongoDB лучше подходит для сложных сущностей, которые имеют несколько уровней вложенности. Такими сущностями могут быть туры в магазине туризма. Тур будет иметь как простые данные (string, number или boolean) такие как название, сложность или продолжительность, так и сложные данные, такие как перечисление гидов, перечисление участников или же координаты рассположения тех или иных остановок по пути самого тура (подобные данные будут массивами с потенциальной вложенностью, так и объекты, поскольку координаты расположения это ширина и долгота). <br/>
- Команда разработчиков уже имеет свой стэк разработки и поэтому MongoDB может не вписаться. <br/>
- Объединение разных типов данных в разных измерениях - это то, что делает реляционные базыд анных фантастическими. MongoDB ре должна делать это хорошо и скорее всего никогда не будет. <br/>
- Использование инструментов, которые её не поддерживают (на момент описания этого README не поддерживаются такие инструметны как SQLAlchemy). <br/>

## Типы данных в MongoDB и операторы сравнения

Типы данных в MongoDB
| Тип данных | Форма записи в запросах | Форма записи в моделях | Примеччание |
| :--------: | :--------------------- | :------------------- | :------- |
|   string   | User.find({nickname: "Avesels"}) | nickname: string | Условие должно быть в двойных кавычках
| number     | User.find({age: 25}) | age: number | Условие должно быть цифрой
| boolean    | User.find({isActive: true}) | isActive: true | Условие должно быть или true или false |
| array      | User.find({car: car}) | car: [string] <br/> holiday: [number] | В квадратных скобках указан любой из простых типов |
| date       | User.find({date: Date.now()}) | date: Date.now() | Как и формулы так и записи конкретных дат |
| ObjectId   | User.find({_id: mongoose.ObjectId}) | UserId: mongoose.Types.ObjectId | Уникальный тип, который должен быть записан через Types |
| Maps       | User.create({location: {latitude: 50.2, longitude: 50.2}}) | location: { type: Map, of: Number} | Объект, в котором заполнется как и тип самого Map так и из чего он состоит |

## Условные операторы сравнения

| Оператор сравнения | Условный оператор | Пояснение |
| :----------------: | :---------------: | :-------- |
| : | = | Равно |
| > | $gt | Строго больше |
| >= | $gte | Больше равно |
| < | $lt | Строго меньше |
| <= | $lte | Меньше равно |

## Запросы c Find
Find это аналог SELECT в SQL базах данных. <br/> <br/>

| Ключевое слово | Описание | Детали | Пример использования | Почснение примера |
| :------------- | :------- | :----- | :------------------- | :---------------- |
| Find | Выполняет запрос выборки | Если не передавать никакого аргумента, то результатом запроса будут все документы из коллекции | Product.find() <br/> Product.find({}) | Предоставить из коллекции Product все документы |
| Find c парами ключ/значение | Выполняет запрос выборки с определенными параметрами | Результатом выборки будут все документы, где есть указанные пары ключ/значение. <br/> <br/> При передачи примитивов, MongoDB, автоматически их правильно считывает | Product.find({"price": 10}) <br/> Product.find({"product_category": "phone"}) <br/> Product.find({"isHave": true}) | Получить все документы из коллекции Product, где ключ price равняется значению 10 |
| Find возвращающий документы с затребоваными ключами | Возвращает результат выборки только с перечисляемыми ключами | Результом выборки будут часть каждого из документа, где есть перечисляемые пары ключ/значение | Product.find({}, {"price": 10, "amount" > 10}) | Возвращает из коллекции Product, только те документы, где есть пары ключ/значения "price": 10 и  "amount" > 10 и возвращает только эти пары ключ/значения из этих документов | 
| Find с условными операторами | Возвращает результат выборки проходящий условия условных операторов | Результатом выборки будет массив документов из коллекции, значения ключей, которые проходят условия | Product.find({"price": {$gte: 20, $lte: 60}}) | Возвращает те документы, в которых цена находится между 20 и 60 | 

## Операторы запроса

| Оператор | Описание | Пример использования | Пояснение примера |
| :------: | :------- | :------------------- | :---------------- |
| $ne | Результирующий набор составляют все значения, кроме тех, которые имеют параметры указаннве в условии | User.find({“username”: {“$ne”: “avesels”}}) | Получить всех пользователей кроме пользователя «avesels” | 
| $in | Результирующий набор составляют только те значение, которые имеют параметры указанные в условии | Ticket.find({“ticket_number”: {“$in”: [735, 99, 123]}}) | Получить документы, где номера билетов составляют: 735, 99, 123 |
| $nin | Результирующий набор составляют все значения, кроме тех, которые подпадают под параметры указанные в условии | Ticket.find({“ticket_number”: {“$nin”: [735, 99, 123]}}) | Получить документы, где номера билетов НЕ составляют: 735, 99, 123 | 
| $or | Результирующий набор составляют все значение проходящие все условия | Ticket.find($or: [{“ticket_number”: {“$in”: [735, 99, 123]}}, “winner”: true) | Получить документы, где номера билетов составляют: 735, 99, 123 и поле winner равно true | 

## Запросы для определённых типов данных

## Лимитирование, пропуск данных, сравнение и сортировка

## Аккумуляторы

## Агрегации

## Индексы

## Нормализация и денормализация

## Populate
