# Выжимка по работе с MongoDB 

Поскольку книга по MongoDB занимает порядка 500 страниц, а гуглить избитые вопросы глупо, мною было принято решение сделать небольшую шпаргалку по MongoDB, пока все эти нюансы не залезут в голову за годы оттачивания рук. Нюансы будут дополнятся в ходе столкновения проблемами или особенностями данной NoSQL базы данных.

## Оглавление
- [Когда не стоит использовать MongoDB](#когда-не-стоит-использовать-mongoDB)
- [Типы данных в MongoDB и операторы сравнения](#типы-данных-в-mongoDB-и-операторы-сравнения)
- [Запросы с Find](#запросы-с-find)
- [Операторы запроса](#операторы-запроса)
- [Запросы для определённых типов данных](#запросы-для-определённых-типов-данных)
- [Геопространственные запросы](#геопространственные-запросы)
- [Лимитирование, пропуск данных, сравнение и сортировка](#лимитирование-пропуск-данных-сравнение-и-сортировка)
- [Аккумуляторы](#аккумуляторы)
- [Агрегации](#агрегации)
- [Индексы](#индексы)
- [Нормализация и денормализация](#нормализация-и-денормализация)
- [Populate](#populate)

## Когда не стоит использовать MongoDB

Тогда, когда нам нужно использовать реляционные базы данных...и тем самым создать Холивар...На самом деле не стоит использовать если: <br/>
- Данные, которые необходимо вбивать являются систематическими с одним уровнем вложенности, проще говоря если база данных состоит из описания сущности электротехники, которая имеет конкретные данные по типу: вес, размер, номер модели, серии, год выпуска и т.д., тогда это проще как и хранить, так и обрабатывать в форме таблички. <br/>
MongoDB лучше подходит для сложных сущностей, которые имеют несколько уровней вложенности. Такими сущностями могут быть туры в магазине туризма. Тур будет иметь как простые данные (string, number или boolean) такие как название, сложность или продолжительность, так и сложные данные, такие как перечисление гидов, перечисление участников или же координаты рассположения тех или иных остановок по пути самого тура (подобные данные будут массивами с потенциальной вложенностью, так и объекты, поскольку координаты расположения это ширина и долгота). <br/>
- Команда разработчиков уже имеет свой стэк разработки и поэтому MongoDB может не вписаться. <br/>
- Объединение разных типов данных в разных измерениях - это то, что делает реляционные базыд анных фантастическими. MongoDB ре должна делать это хорошо и скорее всего никогда не будет. <br/>
- Использование инструментов, которые её не поддерживают (на момент описания этого README не поддерживаются такие инструметны как SQLAlchemy). <br/>

## Типы данных в MongoDB и операторы сравнения

**Типы данных в MongoDB:**

| Тип данных | Форма записи в запросах | Форма записи в моделях | Примеччание |
| :--------: | :--------------------- | :------------------- | :------- |
|   string   | User.find({nickname: "Avesels"}) | nickname: string | Условие должно быть в двойных кавычках
| number     | User.find({age: 25}) | age: number | Условие должно быть цифрой
| boolean    | User.find({isActive: true}) | isActive: true | Условие должно быть или true или false |
| array      | User.find({car: car}) | car: [string] <br/> holiday: [number] | В квадратных скобках указан любой из простых типов |
| date       | User.find({date: Date.now()}) | date: Date.now() | Как и формулы так и записи конкретных дат |
| ObjectId   | User.find({_id: mongoose.ObjectId}) | UserId: mongoose.Types.ObjectId | Уникальный тип, который должен быть записан через Types |
| Maps       | User.create({location: {latitude: 50.2, longitude: 50.2}}) | location: { type: Map, of: Number} | Объект, в котором заполнется как и тип самого Map так и из чего он состоит |

**Условные операторы сравнения:**

| Оператор сравнения | Условный оператор | Пояснение |
| :----------------: | :---------------: | :-------- |
| = | $eq | Равно |
| > | $gt | Строго больше |
| >= | $gte | Больше равно |
| < | $lt | Строго меньше |
| <= | $lte | Меньше равно |

## Запросы c Find
Find это аналог SELECT в SQL базах данных. <br/> <br/>

| Ключевое слово | Описание | Детали | Пример использования | Пояснение примера |
| :------------- | :------- | :----- | :------------------- | :---------------- |
| Find | Выполняет запрос выборки | Если не передавать никакого аргумента, то результатом запроса будут все документы из коллекции | Product.find() <br/> Product.find({}) | Предоставить из коллекции Product все документы |
| Find c парами ключ/значение | Выполняет запрос выборки с определенными параметрами | Результатом выборки будут все документы, где есть указанные пары ключ/значение. <br/> <br/> При передачи примитивов, MongoDB, автоматически их правильно считывает | Product.find({"price": 10}) <br/> Product.find({"product_category": "phone"}) <br/> Product.find({"isHave": true}) | Получить все документы из коллекции Product, где ключ price равняется значению 10 |
| Find возвращающий документы с затребоваными ключами | Возвращает результат выборки только с перечисляемыми ключами | Результом выборки будут часть каждого из документа, где есть перечисляемые пары ключ/значение | Product.find({}, {"price": 10, "amount" > 10}) | Возвращает из коллекции Product, только те документы, где есть пары ключ/значения "price": 10 и  "amount" > 10 и возвращает только эти пары ключ/значения из этих документов | 
| Find с условными операторами | Возвращает результат выборки проходящий условия условных операторов | Результатом выборки будет массив документов из коллекции, значения ключей, которые проходят условия | Product.find({"price": {$gte: 20, $lte: 60}}) | Возвращает те документы, в которых цена находится между 20 и 60 | 

## Операторы запроса

Операторы запроса выполняют функцию фильтрования значений, по наличию или отсутствию параметров указанных в условии запроса. <br/> <br/>

| Оператор | Описание | Пример использования | Пояснение примера |
| :------: | :------- | :------------------- | :---------------- |
| $ne | Результирующий набор составляют все значения, кроме тех, которые имеют параметры указаннве в условии | User.find({“username”: {“$ne”: “avesels”}}) | Получить всех пользователей кроме пользователя «avesels” | 
| $in | Результирующий набор составляют только те значение, которые имеют параметры указанные в условии | Ticket.find({“ticket_number”: {“$in”: [735, 99, 123]}}) | Получить документы, где номера билетов составляют: 735, 99, 123 |
| $nin | Результирующий набор составляют все значения, кроме тех, которые подпадают под параметры указанные в условии | Ticket.find({“ticket_number”: {“$nin”: [735, 99, 123]}}) | Получить документы, где номера билетов НЕ составляют: 735, 99, 123 | 
| $or | Результирующий набор составляют все значение проходящие все условия | Ticket.find($or: [{“ticket_number”: {“$in”: [735, 99, 123]}}, “winner”: true) | Получить документы, где номера билетов составляют: 735, 99, 123 и поле winner равно true | 

## Запросы для определённых типов данных

Поскольку при выборке документов из коллекции, в результирующий набор попадает n-ое количество документов. Чтобы управлять этим n в рамках результируюющего выбора существуют операторы фильтрации этого массива документов. <br/> <br/>

### Операторы по фильтрации массива документов
| Оператор | Описание | Детали | Пример использования |
| :------: | :------- | :----  | :------------------- |
| $all     | Находит все документы с необходимыми элементами в массиве | Порядок описания не имеет значения, поскольку в выборку попадают все документы, в которых есть значения указанные в условии запроса | Tour.find({"tourName": {$all: ["the sky", "winelog"]}}) |
| $size | Ограничивает количество документов, которые будут получены в результирующем наборе | Возвращает массив документов ограниченой длины | Tor.find({"tour": {$size: 3}}) |
| $slice | Возвращает подмножество документов | Возвращает массив документов в ограниченном количестве. <br/> <br/> Если нужны документы с конца необходимо поставить "-" перед числом. <br/> <br/> Если нужны документы из средины массива документов - первым аргументов обозначается элемент с которого начать, вторым аругментом - количество документов | Post.find({"comments": {$slice: 3}}) <br/> <br/> Post.find({"comments": {$slice: -3}}) <br/> <br/> Post.find({"comments": {$slice: [3, 10]}}) |
| $ | Возвращает указанное количество любых документов из массива | Количество элементов указывается после оператора | Post.find({"comments.$": 2}) |
| $elemMatch | Группирует несколько условий выборки | Находит те документы, которые соответствуют всем условиям | Products.find({'freight": {$elemMatch: {$gte: 10, $lt: 20}}}) |

### Запросы для типов Null и регулярных выражений
| Тип | Оператор | Описание | Пример использования |
| :-: | :------: | :------- | :------------------- |
| Null | $exists | В MongoDB тип Null ещё значит, что данных не существует. Используется если нам нужны значения, где значение есть Null, но при этом это и есть искомое значение | User.find({"eq": Null, "$exists": true}) |
| Регулярные выражения | $regex | Если необходимо ввести регулярное выражение как условие запроса | User.find({"nickname": {"$regex": /aves/i}}) |

## Геопространственные запросы

Геометрические запросы отличаются в зависимости от типа геометрической плоскости. Существует 2 геометрические плоскости: 2d или плоская и 2dsphere или сферическая. В зависимости от наявной карты выбирается соответствующие гепространственные запросы.

Типы геопространственных запросов: 
| Оператор | Тип геометрии | Описание |
| :------: | :-----------: | :------- |
|  $near | Сферическая <br> Плоская | Указывает точку, для которой геопространственный запрос возвращает документы от ближайшего к самому дальнему |
| $geoWithin: {$geometry: } | Сферическая | Выбирает документы с геопространственными данными, которые полностью существуют в указанной форме |
| $geoWithin: {$box: } | Сферическая | Выбирает документы с геопространственными данными, которые полностью существуют в указанной форме. Указывается массив из двух массивов: координаты нижней левой точки и верхней правой точки квадрата |
| $geoWithin: {$center: } | Плоская | Выбирает документы с геопространственными данными, которые полностью существуют в указанной форме. Указывается первым аргументом массив из координат начальной точки и вторым аргументом радиус охвата |
| $geoWithin: {$centerSphere: } | Сферическая | Тоже самое, что и $geoWithin : {$center: } только для сферического запроса |
| $geoImtersects | Cферическая | Выбирает документы, геопространственные данные которых пересекаются с указанным объектом GeoJSON; т. е. где пересечение данных и указанного объекта непусто |

### Пример $near
При запросе $near сортирует документы от ближнего к дальнему, при этом можно указать два необязательных параметра: 
- $mixDistance - ограничивает результаты теми документами, которые находятся как минимум на указанном расстоянии от центральной точки.
- $maxDistance - ограничивает результаты теми документами, которые находятся не более чем на указанном расстоянии от центральной точки.
```
{
   <location field>: {
     $near: {
       $geometry: {
          type: "Point" ,
          coordinates: [ <longitude> , <latitude> ]
       },
       $maxDistance: <distance in meters>,
       $minDistance: <distance in meters>
     }
   }
}
```
### Пример $geoWithin: {$geometry: }
```
{
   <location field>: {
      $geoWithin: {
         $geometry: {
            type: <"Polygon"> ,
            coordinates: [ <coordinates> ]
         }
      }
   }
}
```

### Пример $geoWithin: {$box: }
```
{
  <location field>: {
     $geoWithin: {
        $box: [
          [ <bottom left coordinates> ],
          [ <upper right coordinates> ]
        ]
     }
  }
}
```
### Пример $geoWithin: {$center: }
```
{
   <location field>: {
      $geoWithin: { $center: [ [ <x>, <y> ] , <radius> ] }
   }
}
```

### Пример $geoWithin: {$centerSphere: }
```
{
   <location field>: {
      $geoWithin: { $centerSphere: [ [ <x>, <y> ], <radius> ] }
   }
}
```
### Пример $geoImtersects
```
{
  <location field>: {
     $geoIntersects: {
        $geometry: {
           type: "<GeoJSON object type>" ,
           coordinates: [ <coordinates> ]
        }
     }
  }
}
```

## Лимитирование, пропуск данных, сравнение и сортировка

Результирующий набор документов полученный из коллекции можно предать различным методам, если нам нужно ограничить количество документов в результирующем наборе, пропустить обозначенное количество документов, сравнить на соответствие с условием запроса или же отсортировать в нужном порядке. <br/>

### Методы обработки документов
| Метод | Описание | Пример использования | Пояснение примера |
| :---: | :------- | :------------------- | :---------------- |
| .limit() | Предоставляет ограниченное количество документов из коллекции | Product.find().limit(4) | Выдает 4 или меньше, первых продукта из коллекции Product |
| .skiр() | Пропускает ограниченное количество данных из массива коллекции | Product.find().skip(3) | Пропускает первые три документа из коллекции Product |
| .sort() | Сортирует документы по возрастанию или убыванию определенного ключа документа | Product.find().sort({"productName": 1}) <br/> <br/> Product.find().sort({"productName": 1, "price": -1}) | Отсортирует по возрастанию productName каждый из документов коллекции Product <br/> <br/> Отсортирует по возрастанию productName, после чего в каждом productName отсорирует по убыванию стоимости документы из коллекции Product |

### Порядок сравнения
В MongoDB существует иерархия относительно того, как типы сравниваются. Порой может быть один ключ с несколькими типами, например целые числа и логические типы данных или строки и нули. Если выполнять сортировку по ключу со смесью типов, существует предопределённый порядок, в котором они будут отсортированы. Вот как выглядит этот порядок от наименьшего значения к наибольшему: <br/>
1. Минимальное значение. <br/>
2. Ноль. <br/>
3. Числа (целые, длинные, двойные, десятичные). <br/>
4. Объект / документ.
5. Массив.
6. Двоичные данные.
7. Идентификатор объекта.
8. Логический тип данных.
9. Дата.
10. Временная отметка.
11. Регулярное выражение.
12. Максимальное значение. 

## Аккумуляторы

Аккумуляторы служат для того, чтобы вычилсять значения из нескольких документов и предоставлять результат в результирующий набор. Аккумуляторами монжо считать те операции, которые сканируют все документы. <br/> <br/>

| Аккумулятор | Описание | Пример использования | Пояснение примера |
| :---------: | :------- | :------------------- | :---------------- |
| $sum | Суммирует все значения определенного поля во всех документах коллекции | totalPrice: {$sum: "price"} | Получает суммарную итоговую стоимость |
| $avg | Находит среднее значение определенного поля во всех документах коллекции | totalPrice: {$avg: "price} | Получает среднюю стоимость |
| $first | Находит первый документ по значению определенного поля | product: {$first: "phone"} | Получает первый документ у которого есть ключ/значение product: phone |
| $last | Находит последний документ по значению определенного поля | product: {$last: "phone"} | Получает последний документ у которого есть ключ/значение product: phone |
| $min | Находит документ с минимальным значением определенного поля | minPrice: {$min: "price"} | Находит документ с наименшой ценой |
| $max | Находит документ с максимальным значением определенного поля | maxPrice: {$max: "price"} | Находит документ с наибольшей ценой |

## Агрегации

Агрегации вызываются ключевым словом `aggregate`, котороё идёт после точки с названием конкретной коллекции и принимающий массив объектов (условий). <br/> 
Пример агрегации: Tour.aggregate([]). <br/> <br/>

### Механизм агрегации
Агрегации формируются посредством работы операции конвеера. Конвеер состоит из этапов, каждый из которых выполняет свою задачу обработки данных на входе и создает документы в качестве выходных данных для передачи их следующему этапу. Наконец, в конце обработки конвейер создает выходные данные, с которыми мы можем что-то сделать в нашем приложении или которые можно отправить в коллекцию для дальнейшего использования. <br/> <br/>
Из-за последовательного прохождения конвеера очень важно собладть последовательность операций, для достижения как нужных результатов, так и повышения эффективности работы самой агрегации. <br/> <br/>
Каждый из этапов агрегации может быть пропущен, в случае его ненадобности, но при формировании агрегации, в большинстве случаев, необходимо соблюдать следующую последовательность этапов.

Пример агрегации: 
```
Companies:aggregate([
    {$match: {"founded_year": 2004}},
    {$sort: {"name": 1}},
    {$skip: 10},
    {$limit: 5},
    {$project: {
        _id: 0,
        "name": 1
    }}
])
```
### Операторы агрегации
| Оператор | Описание | Порядок следования |
| :------: | :------- | :----------------- |
| $match | Сравнивает значения в документах на соотвествие условию запроса, после чего в следующий этап конвеера попадают только те документы, прошедшие mach | Первый в объекте в массиве конвеера |
| $sort | Сортирует документы по значениям определенного ключа. Сортировка может быть по возрастанию (1) или по убыванию (-1) | Второй объект в массиве конвеера или объект после $match |
| $skip | Пропускает те документы, которые указаны в условии. <br/> <br/> Если в условии указано число, то это число означает количество пропускаемых элементов <br/> <br/> Если в условии указан массив из двух аргументов, значит первый аргумент означает начальный документ, с которого пропускается, а второй аргумент - количество пропускаемых элементов. | Третий объект в массиве конвейера или объект после  $match и/или $sort |
| $limit | Ограничивает количество документов, которые попадают в результирующую выборку | Четвертый объект в массиве конвеера или объект после $match и/или $sort и/или $skip |
| $geoNear | Выводит документы в порядке от ближайшего к самому дальнему от указанной точки | Произвольное размещение |
| $group | Используется для группировки данных | Используется тогда, когда необходима группировка данных, а именно на последнем этапе |
| $push | Используется для создания массива или для добавления значений в массив на каждом этапе $match | Оператор работает только на этапах $group |
| $unwind | Позволяет создать из одного документа с массивом создать вывод таким образом, что для кажого элемента в указанном поле массива имеется один выходной документ | Перед оператором $project |
| $project | Формирует конечный вид документов, которые попадут в результирующий набор, при этом в конечном виде може быть убран ключ _id | Последний этап в формировании конечного вида результата выборки |

#### Детально про $geoNear
В принципе работает как $near в геопространственном запросе, но внутри фреймворка агрегации.

Объект $geoNear внутри блока агрегации: 
```
{ $geoNear: { <geoNear options> } }
```

##### Опции оператора $geoNear
| Опция | Обязательность | Описание |
| :---: | :------------: | :------- |
| distanceField | Обязательно | Поле вывода, содержащее рассчитанное расстояние |
| distanceMultiplier | Необязательно | Коэффициент для умножения всех расстояний, возвращаемых запросом. Например, используйте DistanceMultiplier для преобразования радианов, возвращаемых сферическим запросом, в километры путем умножения на радиус Земли |
| includeLocs | Необязательно | Это задает выходное поле, которое идентифицирует местоположение, используемое для расчета расстояния. Этот параметр полезен, когда поле местоположения содержит несколько местоположений |
| key | Необязательно | Геопространственное индексированное поле для использования при расчете расстояния | 
| maxDistance | Необязательно | Максимальное расстояние от центральной точки, на котором могут находиться документы. MongoDB ограничивает результаты теми документами, которые находятся в пределах указанного расстояния от центральной точки |
| minDistance | Необязательно | Минимальное расстояние от центральной точки, на котором могут находиться документы. MongoDB ограничивает результаты теми документами, которые находятся за пределами указанного расстояния от центральной точки |
| near | Обязательно | Точка, для которой нужно найти ближайшие документы |


#### Детально про $project

Прямой доступ к непосредственному расположению ключа в объекте путём добавления $ перед названием объекта: 

```
{
    $project: {
        _id: 0,
        name: 1,
        ipo: "$ipo.pub_year",
        valuation: "$ipo.valuation_amount",
        funders: "$funding_rounds.investments.financial_org.permalink"
    }
}
```

Здесь ведётся точечная анотация для обозначения путей, которые ведут к полям "ipo" и "funding_rounds" для выбора значений из этих вложенных документов и массивов. Вот как выглядят данные из базы данных из которых происходит создание результирующего набора $project:

```
{
    "_id": "52cdef7c4bab8bd675297d8e", 
    "name": "Facebook", 
    "category_code": "social", 
    "founded_year": 2004, 
    "description": "Social network", 
    "funding_rounds": [
        {
            "id": 4,
            "round_code": "b", 
            "raised_amount": 27500000,
            "raised_currency_code": "USD",
            "funded_year": 2006, 
            "investments": [
                {
                    "company": null,
                    "financial_org": {
                        "name": "Greylock Partners",
                        "permalink": "greylock"
                    },
                "person": null 
                },
                {
                    "company": null, 
                    "financial_org": {
                        "name": "Meritech Capital Partners",
                        "permalink": "meritech-capital-partners" 
                    },
                "person": null 
                },
                {
                    "company": null, 
                    "financial_org": {
                        "name": "Founders Fund",
                        "permalink": "founders-fund"
                    },
                "person": null 
                },
                {
                    "company": null,
                    "financial_org": {
                        "name": "SV Angel",
                        "permalink": "sv-angel" 
                    },
                "person": null 
                }
            ]
        },
        {
            "id": 2197,
            "round_code": "c",
            "raised_amount": 15000000, 
            "raised_currency_code": "USD", 
            "funded_year": 2008, "investments": [
                {
                    "company": null, 
                    "financial_org": {
                        "name": "European Founders Fund",
                        "permalink": "european-founders-fund" 
                    },
                "person": null 
                }
            ]
        }
    ],
    "ipo": {
        "valuation_amount": NumberLong("104000000000"),
        "valuation_currency_code": "USD",
        "pub_year": 2012,
        "pub_month": 5,
        "pub_day": 18,
        "stock_symbol": "NASDAQ:FB"
    }
}
```
#### Детально про $unwind

$unwind выводит из одного объекта - равное количество объектов, количеству элементов в массиве по ключу запроса #unwind.

До реализации $unwind:
```
{
    "key1": "value1"
    "key2": "value2"
    "key3": ["elem1", "elem2", "elem3"]
}
```

После реализации $unwind:
```
[
    {
        "key1": "value1"
        "key2": "value2"
        "key3": "elem1"
    },
    
        "key1": "value1"
        "key2": "value2"
        "key3": "elem2"
    },
    
        "key1": "value1"
        "key2": "value2"
        "key3": "elem3"
    },
]
```

Оператор $unwind используют непосредственно на ключ, значением которого есть объект объектов, в параметре которого указывается ключ первоначального объекта. <br/>
Например:
```
Companies.aggregate([
    { $match: {"funding_rounds.investments.financial_org.permalink": "greylock" }},
    { $unwind: "$funding_rounds"},
    { $project: {
        _id: 0,
        name: 1,
        amount: "$funding_rounds.raised_amount", year: "$funding_rounds.funded_year"
        } 
    }
])
```
В случае же если значением ключа будет выступать массив, то у нас появится проблема вывода, поскольку $unwind сработает не корректно и выведет все тот же массив. Одна из возможностей, как решить проблему  – изменить порядок этапов с операторами $unwind и $match, то есть сначала использовать оператор $unwind, а затем $match. Это гарантирует, что мы будем сопоставлять только документы, выходящие из этапа с $unwind. Но, обдумывая данный подход, быстро становится ясно, что если мы вначале используем этап с оператором $unwind, то просканируем всю коллекцию. <br/> <br/>
Для эффективности нам нужно, чтобы совпадение в нашем конвейере было как можно раньше. Это позволяет, например, фреймворку агрегации использовать индексы. Итак, чтобы выбрать только те раунды размещения ценных бумаг, в которых участвовала компания Greylock, мы можем включить второй этап с оператором $match:
```
db.companies.aggregate([
    { $match: { "funding_rounds.investments.financial_org.permalink": "greylock" } }, 
    { $unwind: "$funding_rounds" },
    { $match: { "funding_rounds.investments.financial_org.permalink": "greylock" } }, 
    { $project: {
        _id: 0,
        name: 1,
        individualFunder: "$funding_rounds.investments.person.permalink", 
        fundingOrganization: "$funding_rounds.investments.financial_org.permalink",
        amount: "$funding_rounds.raised_amount",
        year: "$funding_rounds.funded_year"
    } }
])
```

Этот конвейер сначала отфильтрует компании, в которых Greylock участвовала хотя бы в одном раунде. Затем он использует оператор $unwind для раундов размещения ценных бумаг и снова выполнит фильтрацию, таким образом, только те документы, которые представляют раунды, в которых фактически участвовала компания Greylock, будут переданы в этап с $project. <br/> <br/>
Мы выполняем фильтрацию, чтобы уменьшить количество документов, которые мы рассматриваем изначально, сузив наш набор документов для рассмотрения до тех, где Greylock участвовала как минимум в одном раунде размещения ценных бумаг. Затем, на этапе с оператором $unwind, мы получаем ряд документов, представляющих раунды размещения ценных бумаг от компаний, в которых Greylock фактически участвовала, но отдельные раунды, в которых Greylock не участвовала. Мы можем избавиться ото всех раундов, которые нас не интересуют, просто включив еще один фильтр, используя второй этап с оператором $match.

#### Детально про $push

$push используется для аккумулирования массива и для добавления значения в массив на каждом этапе $match. При этом добавление происходит вконец массива. <br/>
Выражения $push работают только на этапах $group. Это связано с тем, что эти этапы предназначены для приема входного потока документов и накопления значений путем обработки каждого документа по очереди. <br/>

### Применение выражений в фреймворке агрегаций

Фреймворк агрегаций поддерживает множество различных классов выражений:
- Логические выражения позволюющие использовать выражения И / ИЛИ и НЕ. <br/>
- Выражения множеств предоставляют возможность работать с массивами в качестве множеств. В частности позволяет получить пересечение или объединение двух или более множеств, а также может взять разницу двух множеств и выполнить ряд других операций на множествами. <br/>
- Выражения сравнения позволяют выражать мнжество различных типов фильтров диапазонов.<br/>
- Строковые выражения позволяют объединять, находить подстроки и выполнять операции, связанне с регистром и операциями текстового поиска.<br/>
- Выражения массивов предоставляют множество возможностей для манипулирования массивами, включая возможность фильтровать элементы массива, разрезать массив или просто получать диапазон значений из определенного массива.<br/>
- Аккумуляторы предоставляют возможность расчета сумм, описательной статистики и многих других типов значений. <br/> 

## Индексы

Индексы нужны, для быстрого поиска документов по определенному полю, которое привязывается к индексу. Поле должно быть уникальным и не быть пустым. Индексы эффективны когда мы хотим получить данные, поэтому их лучше делать в запросах на получения, а редактирование этих данных можно отгрузить в панель администратора, где скорость обработки документов не столь важна. <br/> <br/>
Уникальный индекс чтобы получился необходимо добавит объект: `{unique: true}`. Например: 
```
Users.createIndex(
    {"age" : 1}, 
    {"unique" : true})
```

Создание простого индекса. Проиндексировать по возрастанию коллекцию User по полю "username": <br/>
```
User.createIndex({“username”: 1})
```
Создание cоставного индекса. Сперва индексирует по возрастанию "age" каждый документ коллекции User, а после индексирует по возрастанию "username" исходя из каждого "age":
```
User.createIndex({“age”: 1, “username”: 1}) 
```

Создание индекса по вложенным полям:
```
Users.createIndex({"loc.city" : 1})
```

### Неефективное использование
Порядок ключей в условии значений имеет значение. Сортировка будет эффективная, если в объекте условия, первым аргументом будет индексирование поле. Запрос `User.find({“age”: 1, “username”: 1})` будет работать плохо если коллекция была проиндексирована по "username" или же работать хорошо, если была проиндексирована по "age". <br/> <br/>

### Неефективные индексы
Запросы с оператором "$ne" могут использовать индекс, но делают они это не очень хорошо. Они должны просматривать все записи индекса, кроме той, которая указана "$ne", по- этому в основном им приходится сканировать весь индекс. <br/>
Оператор "$not" иногда может использовать индекс, но часто не знает, как. <br/>
Оператор "$nin" всегда использует сканирование таблицы. <br/>
При индексировании массивов, массив не считается единой сущностью и поэтому индексирование будет происходит на каждый элемент массива, что может быть как очень плохо если необходимо активное использование CRUD операций и допустимое, если нужно лишь чтение массива.<br/>

### Когда применять индексы
Как правило, индекс часто ускоряет работу, если запрос возвращает 30 % коллекции или более. Однако это число может варьироваться от 2 % до 60 %. Индексы часто хорошо подходят для больших коллекций, больших документов и выборочных запросов. Сканирование коллекции часто хорошо подходит для маленьких коллекций, маленьких документов или неселективных запросов. 

### Геопространственные индексы 

В MongoDB существует два типа геопространственных индексов: 2dsphere и 2d. <br/> <br/> 
Индексы 2dsphere работают с элементами сферической геометрии, которые моделируют поверхность Земли на основе данных WGS84. Эти данные моделируют поверхность Земли в виде сплюснутого сфероида, что означает некоторое выравнивание на полюсах. Таким образом, при расчете расстояния с использованием индексов 2dsphere принимается во внимание форма Земли и обеспечивается более точная обработка расстояния, например между двумя городами по сравнению с индексами 2d. <br/>
Индексы 2d используются для точек, находящихся на двумерной плоскости. <br/> <br/>
2dshere позволяет задавать координаты для точек, линии или полигона. <br/> <br/>

Геопространственный индекс можно создать на нужным объект документа: <br/>
```
OpenRestaurant.createIndex({"loc" : "2dsphere"})
```

#### Точка в 2dshpere
Точка задаётся двухэлементным массивом

```
{
    "name": "New York City", 
    "loc": {
        "type": "Point", 
        "coordinates": [ 50, 2]
    }
}
```
#### Линия в 2dshpere
Линия задается двухмерным массивом с двухэлементными массивами: 
```
{
    "name": "Hudson River", 
    "loc": {
        "type": "LineString",
        "coordinates": [ 
            [ 0, 1 ], 
            [ 0, 2 ], 
            [ 0, 3 ] 
        ] 
    }
}
```
### Полигон в 2dshpere
Полигон также как и линия, но координаты должны формировать последовательную цепочку, которая замыкается
```
{
    "name": "New England", 
    "loc": {
        "type": "Polygon",
        "coordinates" : [
            [0, 1], 
            [0, 2], 
            [1, 2]
        ] 
    }
}
```

## Нормализация и денормализация
Фреймворк агрегации MongoDB предлагает соединения с помощью этапа $lookup, который выполняет левое внешнее соединение, добавляя документы в «объединенную» коллекцию, в которой есть совпадающий документ в исходной коллекции, – добавляет новое поле массива к каждому сопоставленному документу в «объединенной» коллекции с подробностями о документе из исходной коллекции. Эти измененные документы затем доступны на следующем этапе для дальнейшей обработки.

### $lookup - этап агрегации
Выполняет левое внешнее соединение с нерасчлененной коллекцией в той же базе данных для фильтрации документов из «соединенной» коллекции для обработки. К каждому входному документу этап $lookup добавляет новое поле массива, элементами которого являются совпадающие документы из «объединенной» коллекции. Этап $lookup передает эти измененные документы на следующий этап. <br/> <br/>
Решение о том, когда прибегать к нормализации, а когда к денормализации, может быть непростым: обычно нормализация ускоряет запись, а денормализация ускоряет чтение. Таким образом, вам нужно решить, какие компромиссы имеют смысл для вашего приложения:

| Встраивание лучше подходит для ... | Ссылки луччше подходят для ... |
| :-------------------------------- | :---------------------------- |
| Небольших вложенных документов | Больших вложенных документов |
| Данных, которые не меняются регулярно | Изменчивых данных |
| Когда приемлема согласованность в конечном счете | Когда необходима мгновенная последовательность |
| Документов, которые растут на небольшое количество | Документов, которые растут на небольшое количество |
| Данных, для которых часто нужно будет выполнить второй запрос, чтобы получить их | Данных которые часто нужно будет исключать из результатов |
| Быстрых операций чтения | Быстрый операций записи |

## Model 
Каждая схема сопоставляется с коллекцией MongoDB и определяет форму документов в этой коллекции. Создание модели может быть реализовано так:
```
const Blog = mongoose.model('Blog', blogSchema);
```
Схемы состоят из ключей и наборов опций, которые регламентируют значения, которые могут наполнять данные ключи входе применение методов mongoose. Наполнения схемы выглядит так:
```
const schema = new Schema({
    name: String,
    living: Boolean,
    updated: {
        type: Date, 
        default: Date.now
    },
    age: { 
        type: Number, 
        min: 18, 
        max: 65
    },
    mixed: Schema.Types.Mixed,
    _someId: Schema.Types.ObjectId,
    ofString: [String],
})
```
### Опции
Наборы опции определяют и ограничивают ввод значений под те или иные ключи. 

#### Опции описывающие все типы
| Опция | Тип данных | Описание |
| :---: | :--------: | :------- |
| required | boolean | При создании документа это значение должно быть обязательным |
| default | any | Вводит значение по умолчанию |
| validate | function | функция которая валидирует данные |
| get | function | геттер |
| set | function | cеттер |
| alias | string | другое обозначение для данног поля |
| immutable | boolean | не позволяет изменять значение |
|   

Пример validate 
```
const userSchema = new Schema({
  phone: {
    type: String,
    validate: {
      validator: function(v) {
        return /\d{3}-\d{3}-\d{4}/.test(v);
      }
});
```

#### Опции описывающие индексы
Также можете определить индексы MongoDB, используя параметры типа схемы.

| Опция | Тип данных | Описание |
| :---: | :--------: | :------- |
| index | boolean | Определяет ли индекс для этого свойства |
| unique | boolean | Определяет ли уникальный индекс для этого свойства |  

```
const userSchema = new Schema({
  test: {
    type: String,
    index: true,
    unique: true 
  }
});
```
#### Опции описывающие строку
| Опция | Тип данных | Описание |
| :---: | :--------: | :------- |
| lowercase | boolean | Всегда вызывать .toLowerCase() для значения |
| uppercase | boolean | Всегда вызывать .toUpperCase() для значения | 
| trim | boolean | Всегда вызывать .trim() для значения | 
| match | RegExp | Создать регулярное выражение, которое будет служить валидатором для значений | 
| minLength | number | Минимальная длина строки, которая валидируется | 
| maxLength | number | Максимальная длина строки, которая валидируется |
| populate | object | По умолчанию объекты, которые должны быть присоеденены |

#### Опции описывающие числа
| Опция | Тип данных | Описание |
| :---: | :--------: | :------- |
| min | number | Минимальная число которое может быть введено для значения | 
| max | number | Максимальное число которое может быть введено для значения | 
| populate | object | По умолчанию объекты, которые должны быть присоеденены |

#### Опции описывающие дату
| Опция | Тип данных | Описание |
| :---: | :--------: | :------- |
| min | Date | Формат даты | 
| max | Date | Формат даты | 

#### Форма записи опций
```
const breakfastSchema = new Schema({
  eggs: {
    type: Number,
    min: [6, 'Too few eggs'],
    max: 12
  },
  bacon: {
    type: Number,
    required: [true, 'Why no bacon?']
  }
})
```

## Populate
Populate - это процесс автоматической замены указанных путей в документе документом (документами) из других коллекций. Мы можем заполнить один документ, несколько документов, простой объект, несколько простых объектов или все объекты, возвращенные из запроса. <br/> <br/>
Замена происходит путём замещения документов по его ObjectId. Значение заменяется документом mongoose, возвращенным из базы данных путем выполнения отдельного запроса перед возвратом результатов. Массивы ссылок работают одинаково. 

Пример: Найти один документ с определенным заголовком и у этого же документа заменить objectId автора на поле этого автора в коллекции Author
```
Story.findOne({ title: 'Casino Royale' }).populate('author')
```

Если вызывать populate() несколько раз с одним и тем же путем, вступит в силу только последний.
```
Story. find().
  populate({ path: 'fans', select: 'name' }).
  populate({ path: 'fans', select: 'email' });
// Тоже самое что и:
Story.find().populate({ path: 'fans', select: 'email' });
```

### Получение определённых полей для заполнения документов
Что, если мы хотим вернуть только несколько определенных полей для заполненных документов? Этого можно добиться, передав обычный синтаксис имени поля в качестве второго аргумента метода заполнения:

```
Story.
  findOne({ title: /casino royale/i }).
  populate('author', 'name').
```

### Populate нескольких коллекций
Получение данных из нескольких коллекций:
```
Story.
  find(...).
  populate('fans').
  populate('author').
  exec();
```
### Запрос с условием
```
Story.
  find().
  populate({
    path: 'fans',
    match: { age: { $gte: 21 } },
    select: 'name -_id'
  }).
  exec();
```

### Populate через несколько уровней вложенности
Populate позволяет получить список друзей пользователя, но что, если нужно также получить друзей пользователя? Необходимо указать внутри блока populate ещё одного блока populate.
```
User.
  findOne({ name: 'Val' }).
  populate({
    path: 'friends',
    populate: { path: 'friends' }
  });
```

### Populate в промежуточных обработчиках
Populate через pre и post хуки
```
MySchema.pre('find', function() {
  this.populate('user');
});

MySchema.post('save', function() {
  this.populate('user');
});
```
